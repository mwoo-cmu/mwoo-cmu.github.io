<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Enumerations - Rustboro Trainer School (Rust Notes)</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">The Rustboro Trainer School</a></li><li class="chapter-item expanded affix "><a href="dedication.html">Dedication & Acknowledgements</a></li><li class="chapter-item expanded affix "><li class="part-title">A Very Long Introduction to Rust</li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="control_flow.html"><strong aria-hidden="true">2.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="enums.html" class="active"><strong aria-hidden="true">4.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="option.html"><strong aria-hidden="true">5.</strong> Options and Results</a></li><li class="chapter-item expanded "><a href="blocks.html"><strong aria-hidden="true">6.</strong> Blocks and Scope</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">7.</strong> Structs and Tuples</a></li><li class="chapter-item expanded "><a href="traits.html"><strong aria-hidden="true">8.</strong> Traits and Polymorphism</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">9.</strong> Using Macros!</a></li><li class="chapter-item expanded "><a href="macrodef.html"><strong aria-hidden="true">10.</strong> Creating Macros!</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">11.</strong> Visibility</a></li><li class="chapter-item expanded "><a href="borrowing.html"><strong aria-hidden="true">12.</strong> Borrowing</a></li><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">13.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="common_issues.html"><strong aria-hidden="true">14.</strong> Common Issues</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rustboro Trainer School (Rust Notes)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>Since you may not have a ton of experience with enums, I'll explain them in C and Python first. This will also highlight some of the difficulties with enums in those languages, which Rust enums solve.</p>
<h2 id="c-and-python-but-actually-im-just-talking-about-league-for-20-mins"><a class="header" href="#c-and-python-but-actually-im-just-talking-about-league-for-20-mins">C and Python but actually I'm just talking about league for 20 mins</a></h2>
<p>Enumeration types, or enums for short, are typically used to define a set of related constants, typically for comparison. They are not very well-<em>defined</em> (ha ha) in C and Python, and typically take the form of labels assigned to arbitrary integer values (since they're the easiest to work with).</p>
<p>Since enums are somewhat abstract, let's use a concrete example. Suppose we're leagueing some legends and want to specify what lane someone is in. We have 5 total options, and we would write something like this in C and Python.</p>
<pre><code class="language-c">// This is C
#define LANE_TOP 0
#define LANE_JG 1
#define LANE_MID 2
#define LANE_BOT 3
#define LANE_SUP 4
</code></pre>
<pre><code class="language-python"># This is Python
class Lane:
  TOP = 0
  JG = 1
  MID = 2
  BOT = 3
  SUP = 4

# or in a C-like fashion
LANE_TOP = 0
LANE_JG = 1
LANE_MID = 2
LANE_BOT = 3
LANE_SUP = 4
</code></pre>
<p>Since these are all "constant" (nothing is really constant in Python) integer values, we can set and compare variables to them easily. However, there are numerous challenges with this approach:</p>
<p>The first problem with this appreach is that it's difficult to keep track of related information: If we want to keep track of minions farmed for top, mid, and bot, jungle pathing for jg, and ward score for sup, we would need an extra blob of arbitrary data, which we only know the type of based on the value of the lane.</p>
<pre><code class="language-c">// I'm a long C snippet that matt put too much effort into

/* Assuming we have 3 structs to track information of minions farmed,
 * jungle pathing, and ward score, we need to first check the value 
 * of `lane`, then cast this to the correct type in order to use it.
 */
typedef struct CarryInfo_t {
  int minions_farmed;
  // realistically, more stuff here
} CarryInfo;

typedef struct JungleInfo_t {
  // suppose this is some list on the heap of camp constants in order or something
  int *pathing; 
  // more stuff here
} JungleInfo;

typedef struct SupportInfo_t {
  int ward_score;
  // more stuff here
} SupportInfo;

/*
 * Alternatively we may choose to make one struct to store all three
 * of the values, but this would waste memory.
 */
typedef struct AllLanesInfo_t {
  // for supports, this is only helpful to see how many of my cannons 
  // russell has taken after his support item has already completed
  int minions_farmed;
  // for non-junglers, this is only helpful to see how many of justin's
  // camps we've taken from him
  int *pathing;
  // I'm an adc main so I don't actually know what wards are why is this
  // here?
  int ward_score;
} AllLanesInfo;

/*
 * Finally, we have our information struct, which stores the actual lane
 * value, as well as some information
 */
typedef struct ChampInfo_t {
  int lane; // yeah this is what I do but that's besides the point
  void *lane_info;
} ChampInfo;

ChampInfo *info = (ChampInfo *) malloc(sizeof(ChampInfo));
info-&gt;lane = LANE_TOP;
info-&gt;lane_info = malloc(sizeof(CarryInfo));
// wow who's our top laner and how are they losing this hard
((CarryInfo*) info-&gt;lane_info)-&gt;minions_farmed = 15;

// Then if we want to check, we have to test the lane so we can know
// how to look at the `lane_info`
if (info-&gt;lane == LANE_TOP || info-&gt;lane == LANE_BOT || info-&gt;lane == LANE_MID) {
  printf("%d", ((CarryInfo*) info-&gt;lane_info)-&gt;minions_farmed);
} else if (info-&gt;lane == LANE_JG) {
  // iterate through the list and print them all out
} else if (info-&gt;lane == LANE_SUP) {
  printf("%d", ((SupportInfo*) info-&gt;lane_info)-&gt;ward_score);
}
</code></pre>
<p>In Python, it's maybe better?:</p>
<pre><code class="language-python"># I'm a python snippet, but I'm basically the same as the C snippet, but
# I probably have fewer jokes because there's not as much to joke about

# we could use either a dict or a class, but under the hood a class is
# actually a fancy dict with methods and a dict is implemented as a
# class so who's really keeping score

info = {
  "lane": LANE_JG,
  "info": {
    "pathing": [CAMP_OUR_GROMP, CAMP_ENEMY_GROMP, CAMP_OUR_GROMP, CAMP_ENEMY_GROMP],
    # justin the enemy jungler has ganked bot 4 times and taken both
    # dragons and grubs why are you just taking gromp on both sides of 
    # the map
  }
}

# where is justin now?
if info["lane"] == LANE_JG:
  print(info["info"])
elif info["lane"] == LANE_SUP:
  print("Support has warded %s times" % info["info"]["ward_score"])
elif info["lane"] in [LANE_TOP, LANE_MID, LANE_BOT]:
  print("Laner has laned lanily in lane %s" % info["info"]["minions_farmed"])
# what do you mean he pinged on his way bot but is just farming krugs
</code></pre>
<p>But also, since all of these constants are defined as arbitrary integer values, it can be confusing as to which constant a particular integer refers to. If we have multiple different sets of these constants, we may end up with <code>LANE_TOP</code> equivalent to <code>CAMP_ENEMY_GROMP</code>, so if we want to add the lanes that the jungler has ganked to the list, we don't know if they ganked top or took gromp (if it's justin we do though!). Then, we would need to either change some of the constants or add a new way to distinguish between the two.</p>
<h2 id="okay-now-to-rust"><a class="header" href="#okay-now-to-rust">Okay now to Rust</a></h2>
<p>So now that I've gone over what enums are and you're confused and wondering about the emotional well-being of my friend group when we play league, we can talk about Rust, which was the original reason we were here.</p>
<p>Rust bypasses the need for arbitrary values, which solves the second issue. When we define an enum, we don't give it any values at all, and the compiler handles making them different.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I'm a basic rust snippet. I'm probably a midlaner who complains about
// assassins being too weak

// here's our enum
enum Lane {
  Top,
  Jg,
  Mid,
  Bot,
  Sup,
}

// we can do easy comparisons with match statements
let lane: Lane = Lane::Sup;
match lane {
  Lane::Top =&gt; println!("I'm a top laner"),
  Lane::Jg =&gt; println!("I'm a jungle laner"),
  Lane::Mid =&gt; println!("I'm a mid laner"),
  Lane::Bot =&gt; println!("I'm the main character.. right? please tell me I'm the main character"),
  Lane::Sup =&gt; println!("I'm babysitting 4 screaming children please help"),
}
<span class="boring">}</span></code></pre></pre>
<p>The most interesting part about Rust enums, however, is that you can easily tie unique data to the different options. This solves the first issue, since we immediately know what information we're getting, since it's directly attached to the enum member itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I'm a rust version of the C and Python snippets

// for now, just know that this attribute macro allows us to print a Camp
#[derive(Debug)]
enum Camp {
  Gromp,
  Krugs,
  Red,
  Blue,
  Wolves,
  Raptors,
  Grubs,
  Dragon,
  RiftHerald,
  Baron,
}

// Lane enumeration, with associated info!
enum Lane {
  // enum members can have named attributes, like so:
  Top { minions_farmed: u16 },
  // an ordered list of camps our jungler has visited
  Jg { pathing: Vec&lt;Camp&gt; },
  Mid { minions_farmed: u16 },
  // enum members may also have unnamed attributes, in which case the user
  // needs to easily be able to assume what it is. In this case, ADCs don't do
  // anything except farming minions, so we know it must be that
  Bot(u16),
  Sup { ward_score: u16 },
}

let adc: Lane = Lane::Bot(87);
let mid: Lane = Lane::Mid { minions_farmed: 38 };

// we could define cases for all of the other lanes too, if we wanted
match adc {
  Lane::Bot(minions) =&gt; {
    println!("Our bot laner has {} farm. How does the enemy team already have 8 kills?", minions);
  }
  _ =&gt; {}
}

match mid {
  Lane::Mid { minions_farmed } =&gt; {
    println!("Oh, his enemy laner is 8/0 and he only has {} farm", minions_farmed);
  },  // &lt;-- this comma is optional
  _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<h3 id="if-let-and-let-else-statements"><a class="header" href="#if-let-and-let-else-statements">If Let and Let-Else Statements</a></h3>
<p>In the last example, we used match cases with only one case and one default case. For this, we can equivalently use an <code>if let</code> statement.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I am exactly the same as the two `match` statements above!
if let Lane::Bot(minions) = adc {
  println!("Our bot laner has {} farm. How does the enemy team already have 8 kills?", minions);
}

if let Lane::Mid { minions_farmed } = mid {
  println!("Oh, his enemy laner is 8/0 and he only has {} farm", minions_farmed);
} // notably, we can have an `else`, or even an `else if` here.
// though, if we're doing multiple `if let`s, we should use a match instead.
<span class="boring">}</span></code></pre></pre>
<p>Somewhat less useful is a <code>while let</code> statement, which is the <code>while</code> equivalent of the <code>if let</code> statement.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I've literally never used while let before so uh
while let Lane::Bot(minions) = adc {
  println!("Our bot laner has farmed {} minions", minions);
}
<span class="boring">}</span></code></pre></pre>
<p>Suppose we want to require a variable to be one specific enum variant, and we need to exit the function or even (gracefully) crash the program if it is any other value. We can use a <code>let-else</code> statement like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let jann: Lane = Lane::Top { minions_farmed: 0 };

let Lane::Top { minions_farmed } = jann else {
  // the `panic!` macro will immediately exit the program with the given
  // status message
  panic!("Oh no jann's not playing top? It's lost just dodge. Do NOT make me witness that guy's akali or sylas again PLEASE");
};
<span class="boring">}</span></code></pre></pre>
<h2 id="comparing-enums-with-if"><a class="header" href="#comparing-enums-with-if">Comparing Enums With If</a></h2>
<p>We will discuss the <code>#[derive]</code> macro in further detail in the <a href="https://mwoo-cmu.github.io/tools/rustboro/book/macros.html">Using Macros!</a> chapter, but for now, we will just talk about <code>#[derive(PartialEq)]</code>.</p>
<p>Right now, we cannot use the <code>==</code> or <code>!=</code> operators on any of our enums. In order to check them, we must use either a <code>match</code> case or an <code>if let</code> statement.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let justins_current_camp: Camp = Camp::Gromp;
// This is okay
if let Camp::Gromp = justins_current_camp {
  println!("Justin has gromp prio");
} else {
  println!("Justin has lost gromp prio");
}

// This is a compiler error!
if justins_current_camp == Camp::Gromp {
  println!("Justin's still at gromp don't worry");
}
<span class="boring">}</span></code></pre></pre>
<p>If we want to be able to use <code>==</code> and <code>!=</code>, we need to derive <code>PartialEq</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debug lets us print, PartialEq lets us use ==. We can put both in the derive
// macro as arguments
#[derive(Debug, PartialEq)]
enum Camp {
  Gromp,
  Krugs,
  Red,
  Blue,
  Wolves,
  Raptors,
  Grubs,
  Dragon,
  RiftHerald,
  Baron,
}

// Now this is okay
if justins_current_camp == Camp::Gromp {
  println!("Justin is still at gromp");
}
<span class="boring">}</span></code></pre></pre>
<p>This also works with struct enums, and checks their members against each other as well:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq)]
enum Lane {
  Top { minions_farmed: u16 },
  Jg { pathing: Vec&lt;Camp&gt; },
  Mid { minions_farmed: u16 },
  Bot(u16),
  Sup { ward_score: u16 },
}

let good_farm: Lane = Lane::Bot(100);
let adc: Lane = Lane::Bot(89);
if adc != good_farm {
  println!("Our ADC has missed farm");
}

let good_wards: Lane = Lane::Sup { ward_score: 25 };
let sup: Lane = Lane::Sup { ward_score: 25 };
if sup == good_wards {
  println!("Our support has warded wardily");
}
<span class="boring">}</span></code></pre></pre>
<p>Note that if we want to use other comparison operators, such as <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, etc., we need to derive <code>Eq</code>, as well as <code>PartialEq</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="option.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="option.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
