<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rustboro Trainer School (Rust Notes)</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">The Rustboro Trainer School</a></li><li class="chapter-item expanded affix "><a href="dedication.html">Dedication & Acknowledgements</a></li><li class="chapter-item expanded affix "><li class="part-title">Rust</li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="control_flow.html"><strong aria-hidden="true">2.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">4.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="option.html"><strong aria-hidden="true">5.</strong> Options and Results</a></li><li class="chapter-item expanded "><a href="blocks.html"><strong aria-hidden="true">6.</strong> Blocks</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">7.</strong> Structs and Traits</a></li><li class="chapter-item expanded "><a href="borrowing.html"><strong aria-hidden="true">8.</strong> Borrowing</a></li><li class="chapter-item expanded "><a href="common_issues.html"><strong aria-hidden="true">9.</strong> Common Issues</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rustboro Trainer School (Rust Notes)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-rustboro-trainer-school"><a class="header" href="#the-rustboro-trainer-school">The Rustboro Trainer School</a></h1>
<p>Welcome to the Rustboro Trainer School! Hopefully this book can teach you more than just the five nonvolatile status conditions.</p>
<h2 id="some-resources"><a class="header" href="#some-resources">Some Resources</a></h2>
<p><a href="https://play.rust-lang.org/">Test Rust Online</a></p>
<p><a href="https://www.rust-lang.org/tools/install">Install Rust</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dedication"><a class="header" href="#dedication">Dedication</a></h1>
<p>To Aaron, and Gaga (should you choose to come to the dark side).</p>
<h1 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h1>
<p>I would like to acknowledge God for giving me these passions and the talents and abilities to do them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variable-cheatsheet"><a class="header" href="#variable-cheatsheet">Variable Cheatsheet</a></h1>
<h2 id="defining-variables"><a class="header" href="#defining-variables">Defining Variables</a></h2>
<p>Variables are defined with the <code>let</code> keyword, and compile-time constants with the <code>const</code> keyword. Variables are traditionally snake_case, and constants are SCREAMING_SNAKE_CASE, just like in Python or C.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_var = 32;

const MY_CONST: usize = 32;
<span class="boring">}</span></code></pre></pre>
<h2 id="explicit-types"><a class="header" href="#explicit-types">Explicit Types</a></h2>
<p>Types can (and may sometimes be required to) be explicitly stated by adding a colon, followed by the type, after the variable name. Note that all <code>const</code>s must be explicitly typed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// the ': u32' explicitly states that my_var has type `u32` (unsigned 32-bit integer)
let my_var: u32 = 32;
<span class="boring">}</span></code></pre></pre>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>By default, all variables in Rust are immutable, and thus cannot be modified by any means (function calls, operations, etc.). To define a variable as mutable, you must use the <code>mut</code> keyword. Note that <code>const</code>s cannot be mutable, as they are constant.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_var = 32;
my_var += 1;
<span class="boring">}</span></code></pre></pre>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Details</th></tr></thead><tbody>
<tr><td><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></td><td>Unsigned integers (8, 16, 32, 64, or 128 -bit)</td></tr>
<tr><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code></td><td>Signed integers (8, 16, 32, 64, or 128 -bit)</td></tr>
<tr><td><code>f32</code>, <code>f64</code></td><td>Floating Point Numbers (decimal) (32 or 64 -bit)</td></tr>
<tr><td><code>bool</code></td><td>Boolean Value (<code>true</code> or <code>false</code>)</td></tr>
<tr><td><code>char</code></td><td>4-Byte Single Characters (<code>'a'</code>, <code>'0'</code>, etc.)</td></tr>
<tr><td><code>usize</code> and <code>isize</code></td><td>Unsigned/Signed integer, matching the system size (32-bit on 32-bit systems, 64-bit on 64-bit systems)</td></tr>
</tbody></table>
</div>
<h4 id="documentation"><a class="header" href="#documentation">Documentation</a></h4>
<p><a href="https://doc.rust-lang.org/std/primitive.u8.html">u8</a>,
<a href="https://doc.rust-lang.org/std/primitive.u16.html">u16</a>,
<a href="https://doc.rust-lang.org/std/primitive.u32.html">u32</a>,
<a href="https://doc.rust-lang.org/std/primitive.u64.html">u64</a>,
<a href="https://doc.rust-lang.org/std/primitive.u128.html">u128</a>,
<a href="https://doc.rust-lang.org/std/primitive.usize.html">usize</a></p>
<p><a href="https://doc.rust-lang.org/std/primitive.i8.html">i8</a>,
<a href="https://doc.rust-lang.org/std/primitive.i16.html">i16</a>,
<a href="https://doc.rust-lang.org/std/primitive.i32.html">i32</a>,
<a href="https://doc.rust-lang.org/std/primitive.i64.html">i64</a>,
<a href="https://doc.rust-lang.org/std/primitive.i128.html">i128</a>,
<a href="https://doc.rust-lang.org/std/primitive.isize.html">isize</a></p>
<p><a href="https://doc.rust-lang.org/std/primitive.f32.html">f32</a>,
<a href="https://doc.rust-lang.org/std/primitive.f64.html">f64</a></p>
<p><a href="https://doc.rust-lang.org/std/primitive.bool.html">bool</a>,
<a href="https://doc.rust-lang.org/std/primitive.char.html">char</a></p>
<h3 id="arrays-and-vecs"><a class="header" href="#arrays-and-vecs">Arrays and Vecs</a></h3>
<p>Arrays are statically-sized collections of same-type data, and defined with the <code>[type; length]</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// an array of 3 8-bit, unsigned integers
let my_array: [u8; 3] = [0, 1, 2];
<span class="boring">}</span></code></pre></pre>
<p><code>Vec</code>s, or vectors, are dynamically-sized collections of same-type data,and defined using generics as <code>Vec&lt;type&gt;</code>. Items can be pushed to and removed from vectors, changing the total size. They can be initialized with the <code>vec!</code> macro, or using the <code>Vec</code> struct's <code>new</code> classmethod: <code>Vec::new()</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_vec: Vec&lt;u8&gt; = vec![0, 1, 2];
my_vec.push(3);
// my_vec is now [0, 1, 2, 3]

let mut my_new_vec: Vec&lt;bool&gt; = Vec::new();
my_new_vec.push(true);
// my_new_vec is now [true]
<span class="boring">}</span></code></pre></pre>
<h4 id="documentation-1"><a class="header" href="#documentation-1">Documentation</a></h4>
<p><a href="https://doc.rust-lang.org/std/primitive.array.html">array</a>,
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a></p>
<h3 id="string-str"><a class="header" href="#string-str">String &amp;str</a></h3>
<p>Rust has two (yes, two) String types, which can be somewhat difficult to wrap your head around as a new Rust programmer. We will discuss <code>&amp;str</code> in further detail in the <a href="">Borrowing</a> chapter, but for now, <code>&amp;str</code> provides a static, immutable reference to a string, such as what you would get by immediately definining a string in other languages:</p>
<pre><code class="language-python"># This is in Python
print("This would be a &amp;str")
</code></pre>
<pre><pre class="playground"><code class="language-rust">// This is in Rust
fn main() {
  println!("This is a &amp;str");
}</code></pre></pre>
<p>If you need to modify a string (or specifically need a <code>String</code> type for a function call) you can create one either from the <code>String::new()</code> or <code>String::from()</code> constructors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s1 = String::new();
s1.push("Hello, ");
s1.push("World");

let mut s2 = String::from("Hello, world");
s2.push("More text");
<span class="boring">}</span></code></pre></pre>
<p><code>String</code> and <code>&amp;str</code> can be easily converted to one another using <code>to_string()</code>/<code>to_owned()</code> and <code>as_str()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a_str: &amp;str = "I'm a &amp;str";
// Note that calling `to_string` or `to_owned` makes a copy of the str
let a_String: String = a_str.to_owned();
let another_str: &amp;str = a_String.as_str();
<span class="boring">}</span></code></pre></pre>
<h4 id="documentation-2"><a class="header" href="#documentation-2">Documentation</a></h4>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">String</a>,
<a href="https://doc.rust-lang.org/std/primitive.str.html">&amp;str</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-cheatsheet"><a class="header" href="#control-flow-cheatsheet">Control Flow Cheatsheet</a></h1>
<h2 id="if-statements"><a class="header" href="#if-statements">If Statements</a></h2>
<p>If statements do not require parentheses around the condition, like <code>if</code>s in Python, but they use brackets around the contained block, like in C or Java.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if condition {
    // Do something
} else if another_condition {
    // Do something else
} else {
    // Default
}
<span class="boring">}</span></code></pre></pre>
<h2 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h2>
<p>While loops follow a similar format to the if statements, but Rust also provides a shorthand for <code>while true</code> loops with the <code>loop</code> keyword</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while condition {
    // do something
}

loop {
    if !condition {
        break;
    }
    // do something
}
<span class="boring">}</span></code></pre></pre>
<h3 id="labelling-loops"><a class="header" href="#labelling-loops">Labelling Loops</a></h3>
<p>When using multiple nested <code>loop</code>s (including <code>while</code> loops and <code>for</code> loops), you may want to <code>break</code> out of specific loops by labelling them. Note that the label starts with a single quote, but does not end with one.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'outer: loop {
    'inner: while true {
        if condition {
            break 'outer;
        } else if other_condition {
            break 'inner;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="for-loops"><a class="header" href="#for-loops">For Loops</a></h2>
<p>For loops are very similar to Python, and similarly always iterate over a provided iterable. The Rust equivalent to <code>range(start, stop)</code> is <code>start..stop</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 0..10 {
    // will print the values 0 through 9, inclusive
    println!("{}", i);
}

// An array, which is iterable
let array: [u8; 3] = [0, 5, 3];
// call iter on the array to "borrow" its values and iterate over them
for element in array.iter() {
    println!("{}", element);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="switch-cases"><a class="header" href="#switch-cases">Switch Cases</a></h2>
<p>The Rust equivalent of <code>switch</code> cases are <code>match</code> blocks. Switch cases can act as a faster short-hand for a long if-elif-else chain.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match variable {
    value_1 =&gt; {
        // do something
    },
    value_2 =&gt; {
        // do something else
    },
    _ =&gt; {
        // "default" case
    }
}

// Equivalent to
if variable == value_1 {
    // do something
} else if variable == value_2 {
    // do something else
} else {
    // "default" case
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>In Rust, functions are defined with the <code>fn</code> keyword (similar to <code>def</code> in Python). Arguments and return type are specified in the Python format (<code>arg: type</code> and <code>-&gt; type</code>), though these are very rarely used in Python.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(arg1: u32, arg2: u32) -&gt; u32 {
  // function body goes here
  // make sure to return a `u32`!
  return arg1 + arg2;
}

// for a final return value (at the end of the function body) the `return`
// keyword may be omitted
fn also_add(arg1: u32, arg2: u32) -&gt; u32 {
  // note the lack of `return` keyword AND the lack of trailing semicolon,
  // indicating a return value
  arg1 + arg2
}
<span class="boring">}</span></code></pre></pre>
<p>Note that the return type (and the arrow) may be omitted for a function without a return value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn no_return(arg: u32) {
  println!("{}", arg);
  // doesn't return anything
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-and-error-handling"><a class="header" href="#enums-and-error-handling">Enums and Error Handling</a></h1>
<h2 id="c-and-python-but-actually-im-just-talking-about-league-for-20-mins"><a class="header" href="#c-and-python-but-actually-im-just-talking-about-league-for-20-mins">C and Python but actually I'm just talking about league for 20 mins</a></h2>
<p>Enumeration types, or enums for short, are typically used to define a set of related constants, typically for comparison. They are not very well-<em>defined</em> (ha ha) in C and Python, and typically take the form of labels assigned to arbitrary integer values (since they're the easiest to work with).</p>
<p>Since enums are somewhat abstract, let's use a concrete example. Suppose we're leagueing some legends and want to specify what lane someone is in. We have 5 total options, and we would write something like this in C and Python.</p>
<pre><code class="language-c">// This is C
#define LANE_TOP 0
#define LANE_JG 1
#define LANE_MID 2
#define LANE_BOT 3
#define LANE_SUP 4
</code></pre>
<pre><code class="language-python"># This is Python
class Lane:
  TOP = 0
  JG = 1
  MID = 2
  BOT = 3
  SUP = 4

# or in a C-like fashion
LANE_TOP = 0
LANE_JG = 1
LANE_MID = 2
LANE_BOT = 3
LANE_SUP = 4
</code></pre>
<p>Since these are all "constant" (nothing is really constant in Python) integer values, we can set and compare variables to them easily. However, there are numerous challenges with this approach:</p>
<p>The first problem with this appreach is that it's difficult to keep track of related information: If we want to keep track of minions farmed for top, mid, and bot, jungle pathing for jg, and ward score for sup, we would need an extra blob of arbitrary data, which we only know the type of based on the value of the lane.</p>
<pre><code class="language-c">// I'm a long C snippet that matt put too much effort into

/* Assuming we have 3 structs to track information of minions farmed,
 * jungle pathing, and ward score, we need to first check the value 
 * of `lane`, then cast this to the correct type in order to use it.
 */
typedef struct CarryInfo_t {
  int minions_farmed;
  // realistically, more stuff here
} CarryInfo;

typedef struct JungleInfo_t {
  // suppose this is some list on the heap of camp constants in order or something
  int *pathing; 
  // more stuff here
} JungleInfo;

typedef struct SupportInfo_t {
  int ward_score;
  // more stuff here
} SupportInfo;

/*
 * Alternatively we may choose to make one struct to store all three
 * of the values, but this would waste memory.
 */
typedef struct AllLanesInfo_t {
  // for supports, this is only helpful to see how many of my cannons 
  // russell has taken after his support item has already completed
  int minions_farmed;
  // for non-junglers, this is only helpful to see how many of justin's
  // camps we've taken from him
  int *pathing;
  // I'm an adc main so I don't actually know what wards are why is this
  // here?
  int ward_score;
} AllLanesInfo;

/*
 * Finally, we have our information struct, which stores the actual lane
 * value, as well as some information
 */
typedef struct ChampInfo_t {
  int lane; // yeah this is what I do but that's besides the point
  void *lane_info;
} ChampInfo;

ChampInfo *info = (ChampInfo *) malloc(sizeof(ChampInfo));
info-&gt;lane = LANE_TOP;
info-&gt;lane_info = malloc(sizeof(CarryInfo));
// wow who's our top laner and how are they losing this hard
((CarryInfo*) info-&gt;lane_info)-&gt;minions_farmed = 15;

// Then if we want to check, we have to test the lane so we can know
// how to look at the `lane_info`
if (info-&gt;lane == LANE_TOP || info-&gt;lane == LANE_BOT || info-&gt;lane == LANE_MID) {
  printf("%d", ((CarryInfo*) info-&gt;lane_info)-&gt;minions_farmed);
} else if (info-&gt;lane == LANE_JG) {
  // iterate through the list and print them all out
} else if (info-&gt;lane == LANE_SUP) {
  printf("%d", ((SupportInfo*) info-&gt;lane_info)-&gt;ward_score);
}
</code></pre>
<p>In Python, it's maybe better?:</p>
<pre><code class="language-python"># I'm a python snippet, but I'm basically the same as the C snippet, but
# I probably have fewer jokes because there's not as much to joke about

# we could use either a dict or a class, but under the hood a class is
# actually a fancy dict with methods and a dict is implemented as a
# class so who's really keeping score

info = {
  "lane": LANE_JG,
  "info": {
    "pathing": [CAMP_OUR_GROMP, CAMP_ENEMY_GROMP, CAMP_OUR_GROMP, CAMP_ENEMY_GROMP],
    # justin the enemy jungler has ganked bot 4 times and taken both
    # dragons and grubs why are you just taking gromp on both sides of 
    # the map
  }
}

# where is justin now?
if info["lane"] == LANE_JG:
  print(info["info"])
elif info["lane"] == LANE_SUP:
  print("Support has warded %s times" % info["info"]["ward_score"])
elif info["lane"] in [LANE_TOP, LANE_MID, LANE_BOT]:
  print("Laner has laned lanily in lane %s" % info["info"]["minions_farmed"])
# what do you mean he pinged on his way bot but is just farming krugs
</code></pre>
<p>But also, since all of these constants are defined as arbitrary integer values, it can be confusing as to which constant a particular integer refers to. If we have multiple different sets of these constants, we may end up with <code>LANE_TOP</code> equivalent to <code>CAMP_ENEMY_GROMP</code>, so if we want to add the lanes that the jungler has ganked to the list, we don't know if they ganked top or took gromp (if it's justin we do though!). Then, we would need to either change some of the constants or add a new way to distinguish between the two.</p>
<h2 id="okay-now-to-rust"><a class="header" href="#okay-now-to-rust">Okay now to Rust</a></h2>
<p>So now that I've gone over what enums are and you're confused and wondering about the emotional well-being of my friend group when we play league, we can talk about Rust, which was the original reason we were here.</p>
<p>Rust bypasses the need for arbitrary values, which solves the second issue. When we define an enum, we don't give it any values at all, and the compiler handles making them different.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I'm a basic rust snippet. I'm probably a midlaner who complains about
// assassins being too weak

// here's our enum
enum Lane {
  Top,
  Jg,
  Mid,
  Bot,
  Sup,
}

// we can do easy comparisons with match statements
let lane: Lane = Lane::Sup;
match lane {
  Lane::Top =&gt; println!("I'm a top laner"),
  Lane::Jg =&gt; println!("I'm a jungle laner"),
  Lane::Mid =&gt; println!("I'm a mid laner"),
  Lane::Bot =&gt; println!("I'm the main character.. right? please tell me I'm the main character"),
  Lane::Sup =&gt; println!("I'm babysitting 4 screaming children please help"),
}
<span class="boring">}</span></code></pre></pre>
<p>The most interesting part about Rust enums, however, is that you can easily tie unique data to the different options. This solves the first issue, since we immediately know what information we're getting, since it's directly attached to the enum member itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I'm a rust version of the C and Python snippets

// for now, just know that this attribute macro allows us to print a Camp
#[derive(Debug)]
enum Camp {
  Gromp,
  Krugs,
  Red,
  Blue,
  Wolves,
  Raptors,
  Grubs,
  Dragon,
  RiftHerald,
  Baron,
}

// Lane enumeration, with associated info!
enum Lane {
  // enum members can have named attributes, like so:
  Top { minions_farmed: u16 },
  // an ordered list of camps our jungler has visited
  Jg { pathing: Vec&lt;Camp&gt; },
  Mid { minions_farmed: u16 },
  // enum members may also have unnamed attributes, in which case the user
  // needs to easily be able to assume what it is. In this case, ADCs don't do
  // anything except farming minions, so we know it must be that
  Bot(u16),
  Sup { ward_score: u16 },
}

let adc: Lane = Lane::Bot(87);
let mid: Lane = Lane::Mid { minions_farmed: 38 };

// we could define cases for all of the other lanes too, if we wanted
match adc {
  Lane::Bot(minions) =&gt; {
    println!("Our bot laner has {} farm. How does the enemy team already have 8 kills?", minions);
  }
  _ =&gt; {}
}

match mid {
  Lane::Mid { minions_farmed } =&gt; {
    println!("Oh, his enemy laner is 8/0 and he only has {} farm", minions_farmed);
  },  // &lt;-- this comma is optional
  _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<h3 id="if-let-and-let-else-statements"><a class="header" href="#if-let-and-let-else-statements">If Let and Let-Else Statements</a></h3>
<p>In the last example, we used match cases with only one case and one default case. For this, we can equivalently use an <code>if let</code> statement.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I am exactly the same as the two `match` statements above!
if let Lane::Bot(minions) = adc {
  println!("Our bot laner has {} farm. How does the enemy team already have 8 kills?", minions);
}

if let Lane::Mid { minions_farmed } = mid {
  println!("Oh, his enemy laner is 8/0 and he only has {} farm", minions_farmed);
} // notably, we can have an `else`, or even an `else if` here.
// though, if we're doing multiple `if let`s, we should use a match instead.
<span class="boring">}</span></code></pre></pre>
<p>Somewhat less useful is a <code>while let</code> statement, which is the <code>while</code> equivalent of the <code>if let</code> statement.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// I've literally never used while let before so uh
while let Lane::Bot(minions) = adc {
  println!("Our bot laner has farmed {} minions", minions);
}
<span class="boring">}</span></code></pre></pre>
<p>Suppose we want to require a variable to be one specific enum variant, and we need to exit the function or even (gracefully) crash the program if it is any other value. We can use a <code>let-else</code> statement like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let jann: Lane = Lane::Top { minions_farmed: 0 };

let Lane::Top { minions_farmed } = jann else {
  // the `panic!` macro will immediately exit the program with the given
  // status message
  panic!("Oh no jann's not playing top? It's lost just dodge. Do NOT make me witness that guy's akali or sylas again PLEASE");
};
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options-and-results"><a class="header" href="#options-and-results">Options and Results</a></h1>
<p>Rust doesn't have traditional <code>null</code> pointers and error handling (aside from the <code>panic!</code> macro), and relies on two built-in enumerations to manage these.</p>
<h2 id="null-using-option"><a class="header" href="#null-using-option">null Using Option<T></a></h2>
<p><code>Option&lt;T&gt;</code> is a generic enumeration defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// T is a generic argument passed into the type (similar to its use in  Java or C++)
enum Option&lt;T&gt; {
  None, // null equivalent
  Some(T), // non-null equivalent
}
<span class="boring">}</span></code></pre></pre>
<p>When you initialise an <code>Option</code> value, you need to tell the compiler what type <code>T</code> represents. For example, if you want a variable that could be either a <code>String</code> or <code>None</code>, you would create a variable like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// because `Option` is a built-in enum, you don't need to qualify the attributes 
// like Option::Some or Option::None.
let maybe_string: Option&lt;String&gt; = Some(String::from("Is a string"));

// check whether maybe_string is a string or not
if let Some(s) = maybe_string {
  println!("It's a string: {}", s);
} else {
  // {:?} means to print debug info, for things with the `#[derive(Debug)]`
  // attribute. Option has the #[derive(Debug)] attribute, among many others
  println!("It's not a string: {:?}", maybe_string);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="errors-and-not-errors"><a class="header" href="#errors-and-not-errors">Errors and Not-Errors</a></h2>
<p>In many other languages, a function may throw an exception to the exception handler, which manages the error and decides whether or not to exit the program. In Rust, however, errors are managed with the built-in <code>Result</code> enum, or with <code>panic!</code>ing. Using <code>Result</code> is typically preferable, especially for recoverable errors.</p>
<p><code>Result&lt;T, E&gt;</code> is also generic, and defined as follows, with two generic types (one for valid, and one for error):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
  // a non-erroneous return value, with user-provided type T
  Ok(T),
  // an erroneous return value, with user-provided error type E
  Err(E),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="unwrapping-like-its-christmas"><a class="header" href="#unwrapping-like-its-christmas">Unwrapping Like It's Christmas</a></h2>
<p>Both <code>Result</code> and <code>Option</code> provide an <code>unwrap</code> method (among many others), which performs something similar to this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These are the equivalents, the method is defined on Option and Result, and 
// can just be used with the . operator as: `opt.unwrap()` or `res.unwrap()`

// basically, return the inner type T of the Option
fn unwrap&lt;T&gt;(opt: Option&lt;T&gt;) -&gt; T {
  match opt {
    // equivalent to dereferencing a valid pointer
    Some(t) =&gt; t,
    // equivalent to dereferencing a null pointer
    None =&gt; panic!("Called unwrap on `None` value"),
  }
}

// return the valid inner type of the Result
fn unwrap&lt;T, E&gt;(res: Result&lt;T, E&gt;) -&gt; T {
  match res {
    // equivalent to working with the valid return value of a function
    Ok(t) =&gt; t,
    // immediately crash the program when an error is thrown
    Err(e) =&gt; panic!("Called unwrap on `Err` value {:?}", e),
  }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="the-enemy-mids-all-chat-after-he-solo-kills-the-your-mid"><a class="header" href="#the-enemy-mids-all-chat-after-he-solo-kills-the-your-mid">The Enemy Mid's All Chat After He Solo Kills The Your Mid</a></h2>
<p>When a function returns a <code>Result</code>, and is called within another function that returns a <code>Result</code> with the same error type, you can use the fabled <code>?</code> operator.</p>
<p>The <code>?</code> operator performs the equivalent of the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The equivalent of `result?`
match result {
  Ok(t) =&gt; t,
  Err(e) =&gt; return Err(e),
}  
<span class="boring">}</span></code></pre></pre>
<p>The actual usage of the <code>?</code> operator looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn err_func(val: u32) -&gt; Result&lt;u32, String&gt; {
  if val == 0 {
    return Err("String Error".to_owned());
  }
  Ok(val)
}

fn caller(val: u32) -&gt; Result&lt;f32, String&gt; {
  // note the `?` will set `int` to val, if it's Ok, or will return 
  // Err("String Error") from this caller function as a whole if it's Err.
  let int: u32 = err_func(val)?;
  Ok(int as f32)
}

fn another(val: u32) -&gt; Result&lt;u32, i8&gt; {
  // This will not compile, since `String` is different from `i8`, and thus 
  // cannot be directly returned
  let int: u32 = err_func(val)?;
  Ok(int)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="use-the-anyhow-crate-for-better-results"><a class="header" href="#use-the-anyhow-crate-for-better-results">Use the <code>anyhow</code> Crate for Better Results</a></h2>
<p>We haven't talked too much about libraries (called crates) and Rust's package manager, but they are relatively easy to use, and feel similar to Python's pip. The Rust community has provided a special crate for easy error handling called <a href="https://crates.io/crates/anyhow">anyhow</a>.</p>
<p>Anyhow can be added to a project by running <code>cargo add anyhow</code> in the command line within the project, and provides a new <code>Result</code> type and the <code>anyhow!</code> macro, along with many other useful error handling tools.</p>
<p>In the previous section, we saw how mismatched error types prevents the <code>?</code> operator from functioning properly. The <code>anyhow::Result&lt;T&gt;</code> enum allows for handling multiple different error types in a single <code>Result</code>, allowing us to bypass this issue. When creating a new error with <code>anyhow::Result</code>, we use the <code>anyhow::anyhow!</code> macro.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this import overwrites the built-in Rust `Result`, so now all `Results` in
// this snippet refer to anyhow::Result.
use anyhow::{Result, anyhow};

// Note that this probably doesn't actually work with these specific error
// types, but this is a simple example that gets the idea across.

fn err_func(val: u32) -&gt; Result&lt;u32&gt; {
  if val == 0 {
    return Err(anyhow!("Value is 0"));
  }
  Ok(val)
}

fn caller(val: u32) -&gt; Result&lt;f32&gt; {
  // note the `?` will set `int` to val, if it's Ok, or will return 
  // Err("String Error") from this caller function as a whole if it's Err.
  let int: u32 = err_func(val)?;
  // multiple `?`s because enemy mid got ganked and got a double
  let f: f32 = alt_err(int)?;
}

fn alt_err(val: u32) -&gt; Result&lt;f32&gt; {
  let f: f32 = val as f32;
  if f &lt; 0 {
    return Err(anyhow!("value overflow"));
  }
  Ok(f)
}

fn another(val: u32) -&gt; Result&lt;u32&gt; {
  // anyhow allows us to not worry about what error types we're working with
  let int: u32 = err_func(val)?;
  Ok(int)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks"><a class="header" href="#blocks">Blocks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-traits"><a class="header" href="#structs-and-traits">Structs and Traits</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
